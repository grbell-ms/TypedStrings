using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Threading;

namespace TypedStrings
{
    [Generator]
    public sealed class Generator : IIncrementalGenerator
    {
        private const string AttributeName = $"{nameof(TypedStrings)}.{nameof(TypedStringAttribute)}";
        private static readonly string s_generatedCodeAttribute = $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{typeof(Generator).Assembly.GetName().Name}\", \"{typeof(Generator).Assembly.GetName().Version}\")]";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<TypedStringStruct> typedStringStructs =
                context.SyntaxProvider.ForAttributeWithMetadataName(
                    AttributeName,
                    (node, _) => node is StructDeclarationSyntax,
                    GetSemanticTargetForGeneration)
                .Where(x => x is not null)!;

            context.RegisterSourceOutput(typedStringStructs, EmitSourceFile);
        }

        private static void GenType(TypedStringStruct tss, StringBuilder sb)
        {
            if (!string.IsNullOrWhiteSpace(tss.Namespace))
            {
                sb.AppendLine($@"
namespace {tss.Namespace}
{{");
            }

            sb.AppendLine($@"
    {s_generatedCodeAttribute}
    partial struct {tss.StructName} : global::System.IEquatable<{tss.StructName}>
    {{
        public string Raw {{ get; }} 

        public bool Equals({tss.StructName} other) =>
            {tss.ComparerFullName}.Equals(this.Raw, other.Raw);

        public bool GetHashCode() =>
            {tss.ComparerFullName}.GetHashCode(this.Raw);

        public bool Equals(string other) =>
            {tss.ComparerFullName}.Equals(this.Raw, other);

        public static bool operator==({tss.StructName} left, {tss.StructName} right) =>
            {tss.ComparerFullName}.Equals(left.Raw, right.Raw);

        public static bool operator!=({tss.StructName} left, {tss.StructName} right) =>
            !{tss.ComparerFullName}.Equals(left.Raw, right.Raw);
        
        public static bool operator==(atring left, {tss.StructName} right) =>
            {tss.ComparerFullName}.Equals(left, right.Raw);

        public static bool operator!=(string left, {tss.StructName} right) =>
            !{tss.ComparerFullName}.Equals(left, right.Raw);

        public static bool operator==({tss.StructName} left, string right) =>
            {tss.ComparerFullName}.Equals(left.Raw, right);

        public static bool operator!=({tss.StructName} left, string right) =>
            !{tss.ComparerFullName}.Equals(left.Raw, right);

        public static implicit operator string({tss.StructName} x) => x.Raw;
");



            sb.AppendLine($@"
    }}");

            if (!string.IsNullOrWhiteSpace(tss.Namespace))
            {
                sb.AppendLine($@"
}}");
            }
        }

        private static void EmitSourceFile(SourceProductionContext context, TypedStringStruct ec)
        {
            StringBuilder sb = new StringBuilder(1024);

            sb.AppendLine(@"// <auto-generated/>");
            sb.AppendLine();
            sb.AppendLine("using System;");
            GenType(ec, sb);

            context.AddSource($"{ec.StructName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static TypedStringStruct? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
        {
            var classDef = (ClassDeclarationSyntax)context.TargetNode;
            NamespaceDeclarationSyntax? ns = classDef.Parent as NamespaceDeclarationSyntax;
            if (ns is null)
            {
                if (classDef.Parent is not CompilationUnitSyntax)
                {
                    // since this generator doesn't know how to generate a nested type...
                    return null;
                }
            }

            TypedStringStruct? eventSourceClass = null;

            foreach (AttributeData attribute in context.TargetSymbol.GetAttributes())
            {
                if (attribute.AttributeClass?.Name != $"{nameof(TypedStringAttribute)}" ||
                    attribute.AttributeClass.ToDisplayString() != AttributeName || 
                    attribute.ConstructorArguments.IsDefaultOrEmpty ||
                    attribute.ConstructorArguments[0].Value is not Type comparerType)
                {
                    continue;
                }

                var nspace = ConstructNamespace(ns);
                string structName = classDef.Identifier.ValueText;
                eventSourceClass = new TypedStringStruct(nspace, structName, comparerType.FullName);
                break;
            }

            return eventSourceClass;
        }

        private static string ConstructNamespace(NamespaceDeclarationSyntax? ns)
        {
            if (ns is null)
                return string.Empty;

            string nspace = ns.Name.ToString();
            while (true)
            {
                ns = ns.Parent as NamespaceDeclarationSyntax;
                if (ns == null)
                {
                    break;
                }

                nspace = $"{ns.Name}.{nspace}";
            }

            return nspace;
        }

    }

    internal record TypedStringStruct(string Namespace, string StructName, string ComparerFullName)
    {
    }

    public sealed class TypedStringAttribute : Attribute
    {
        public Type Comparer { get; }

        public TypedStringAttribute(Type comparer) => Comparer = comparer;
    }
}


namespace System.Runtime.CompilerServices
{
    internal static class IsExternalInit
    {
    }
}